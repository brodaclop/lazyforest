{"version":3,"sources":["Vector.tsx","ShapeDrawer.tsx","Random.tsx","generators/Road.tsx","generators/SceneObjects.tsx","SceneGenerator.tsx","textures/gravel.jpg","textures/grass.jpg","textures/tree.png","textures/tree2.png","textures/rock.png","textures/dirtroad.jpg","textures/lightergrass.jpg","textures/water.jpg","textures/bridge.png","textures/bridge2.png","Textures.tsx","TextureSelector.tsx","ObjectLayerCard.tsx","CreateLayerCard.tsx","ListComponent.tsx","RoadLayerCard.tsx","VisualsCard.tsx","BaseLayerCard.tsx","RiverLayerCard.tsx","Canvas.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["lineLength","from","to","Math","sqrt","normalize","vector","len","lineNormal","stretch","length","add","origin","subtract","invert","fromPolar","magnitude","dir","cos","sin","intersection","a","b","vectorA","vectorB","diff","ua_t","ub_t","u_b","ua","ub","window","test","drawScene","context","textures","scene","debug","globalScale","canvas","width","size","height","reset","setTransform","DOMMatrix","shadowOffsetX","shadowOffsetY","shadowColor","shadowBlur","fillStyle","strokeStyle","scale","drawPath","vertices","beginPath","moveTo","slice","forEach","vertex","lineTo","closePath","sceneArea","shape","texture","name","edgeShade","rotate","textureScale","translate","stretchWidth","stretchHeight","angle","atan2","imageScale","loadedImage","drawImage","save","createPattern","fill","restore","area","ret","i","p0","p1","p2","normal1","normal2","normal","push","original","reverse","borderArea","transparentImage","lineWidth","stroke","sceneObject","shadowDirection","orientation","naturalWidth","naturalHeight","shadowVector","point","style","arc","PI","debugPoint","radius","clearRect","console","log","Object","values","layers","layer","areas","sort","objects","ob","tint","fillRect","x","y","randomInt","max","floor","random","randomBetween","splitLine","splitRatio","lineVector","relative","splitPoint","perturbation","createRectangle","widthAdjustment","centerline","topLine","map","bottomLine","generateRoad","bridgeTexture","river","intersectionPoints","line","fraction","intersect","bridge1","bridge2","idx","split","splice","Road","endpoints","midpoint","reduce","acc","curr","flatMap","ep","placeObject","dim","avoid","tries","tried","candidate","every","spreadObjects","count","newPoint","concat","warn","inShapeFactory","OffscreenCanvas","getContext","path","Path2D","isPointInPath","SceneObjects","exclude","shapeChecker","filter","sc","randomEdgePoint","side","chosenDim","pos","Error","SceneGenerator","baseTexture","base","type","mainWidth","mainEndpoints","sideRoads","extraEndpoints","bridge","currentObjects","roadAreas","road","newObjects","TINTS","sunset","evening","night","TEXTURES","url","water","category","gravel","dirt","grass","lighterGrass","tree","tree2","rock","makeImageTransparent","image","offscreen","osContext","imageData","getImageData","data","src","set","putImageData","output","Image","convertToBlob","blob","URL","createObjectURL","Textures","onLoaded","useReducer","prevstate","action","imagesLoaded","imageLoaded","useEffect","loaded","t","document","getElementById","id","display","alt","onLoad","TextureSelector","value","onChange","Select","_","placeholder","options","keys","key","text","ObjectLayerCard","generateObjects","clearLayer","deleteLayer","useState","setCount","setTexture","Card","Header","textAlign","Content","Input","label","step","e","Number","target","ButtonGroup","Button","content","icon","disabled","onClick","CreateLayerCard","onCreate","setName","includes","ListComponent","items","itemFactory","addItem","removeItem","itemIcon","List","divided","relaxed","range","index","Item","Icon","floated","RoadLayerCard","generateRoads","sceneHasRiver","setMainWidth","setBridgeTexture","setSideRoads","VisualsCard","onShadowChange","onTintChange","resolution","onResolutionChange","onEdgeShadeChange","shadowLength","round","shadowAngle","BaseLayerCard","createScene","setWidth","setHeight","RiverLayerCard","generateRiver","Canvas","canvasRef","useRef","setTeztures","setScene","setResolution","setDebug","regenerateRoads","useCallback","regenerateRiver","removeLayer","createLayer","dimension","current","onTexturesLoaded","textureMap","Group","itemsPerRow","bind","shadow","Checkbox","checked","toggle","ref","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.b7095480.chunk.js","sourcesContent":["export type Point = [number, number];\r\n\r\nexport const lineLength = (from: Point, to: Point = [0, 0]): number => Math.sqrt((from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]));\r\n\r\nexport const normalize = (vector: Point): Point => {\r\n    const len = lineLength([0, 0], vector);\r\n    return [vector[0] / len, vector[1] / len];\r\n}\r\n\r\nexport const lineNormal = (from: Point, to: Point): Point => normalize([from[1] - to[1], to[0] - from[0]]);\r\n\r\nexport const stretch = (vector: Point, length: number): Point => [vector[0] * length, vector[1] * length];\r\n\r\nexport const add = (origin: Point, vector: Point): Point => [origin[0] + vector[0], origin[1] + vector[1]];\r\n\r\nexport const subtract = (origin: Point, vector: Point): Point => [origin[0] - vector[0], origin[1] - vector[1]];\r\n\r\nexport const relative = (origin: Point, to: Point): Point => [to[0] - origin[0], to[1] - origin[1]];\r\n\r\nexport const invert = (vector: Point): Point => [-vector[0], -vector[1]];\r\n\r\nexport const fromPolar = (magnitude: number, dir: number): Point => [Math.cos(dir) * magnitude, Math.sin(dir) * magnitude];\r\n\r\nexport const dot = (one: Point, other: Point): number => one[0] * other[0] + one[1] * other[1];\r\n\r\nexport const intersection = (a: [Point, Point], b: [Point, Point]): number | null => {\r\n\r\n    const vectorA = subtract(a[1], a[0]);\r\n    const vectorB = subtract(b[1], b[0]);\r\n    const diff = subtract(a[0], b[0]);\r\n\r\n    const ua_t = vectorB[0] * diff[1] - vectorB[1] * diff[0];\r\n    const ub_t = vectorA[0] * diff[1] - vectorA[1] * diff[0];\r\n    var u_b = vectorB[1] * vectorA[0] - vectorB[0] * vectorA[1];\r\n\r\n    if (u_b !== 0) {\r\n        const ua = ua_t / u_b;\r\n        const ub = ub_t / u_b;\r\n\r\n        if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\r\n            return ua;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\ndeclare const window: any;\r\n\r\nwindow.test = intersection;","import { Scene, SceneArea, SceneObject } from \"./Scene\";\r\nimport { Texture } from \"./Textures\";\r\nimport { add, lineLength, lineNormal, normalize, Point, stretch, subtract } from \"./Vector\";\r\nexport const drawScene = (context: CanvasRenderingContext2D, textures: Record<string, Texture>, scene: Scene, debug?: boolean) => {\r\n\r\n    const globalScale: Point = [context.canvas.width / scene.size[0], context.canvas.height / scene.size[1]];\r\n\r\n    const borderArea = (area: SceneArea, width: number): Array<Point> => {\r\n        const ret: Array<Point> = [];\r\n        for (let i = 0; i < area.vertices.length; i++) {\r\n            const p0 = area.vertices[(i + area.vertices.length - 1) % area.vertices.length];\r\n            const p1 = area.vertices[i];\r\n            const p2 = area.vertices[(i + 1) % area.vertices.length];\r\n            const normal1 = lineNormal(p1, p2);\r\n            const normal2 = lineNormal(p0, p1);\r\n            const normal = normalize(add(normal1, normal2));\r\n            ret.push(add(p1, stretch(normal, width)));\r\n        }\r\n        const original = [...area.vertices];\r\n        return [...ret, ret[0], area.vertices[0], ...original.reverse()];\r\n    }\r\n\r\n    const reset = () => {\r\n        context.setTransform(new DOMMatrix());\r\n        context.shadowOffsetX = 0;\r\n        context.shadowOffsetY = 0;\r\n        context.shadowColor = '';\r\n        context.shadowBlur = 0;\r\n        context.fillStyle = '';\r\n        context.strokeStyle = '';\r\n        context.scale(...globalScale);\r\n    }\r\n\r\n    const debugPoint = (point: Point, style: string = '#0ff') => {\r\n        reset();\r\n        context.beginPath();\r\n        context.moveTo(...point);\r\n        context.strokeStyle = style;\r\n        context.fillStyle = style;\r\n        context.arc(...point, 2 / globalScale[0], 0, 2 * Math.PI);\r\n        context.fill();\r\n        context.closePath();\r\n    }\r\n\r\n    const drawPath = (vertices: Array<Point>): void => {\r\n        context.beginPath();\r\n        context.moveTo(...vertices[0]);\r\n        vertices.slice(1).forEach(vertex => {\r\n            context.lineTo(...vertex);\r\n        });\r\n        context.closePath();\r\n    }\r\n\r\n    const sceneArea = (shape: SceneArea) => {\r\n        reset();\r\n\r\n        const texture = textures[shape.texture.name];\r\n\r\n        drawPath(shape.vertices);\r\n\r\n\r\n        //edge shade\r\n        context.shadowColor = 'rgba(30, 30, 30, .9)';\r\n        context.shadowOffsetX = 0;\r\n        context.shadowOffsetY = 0;\r\n        context.shadowBlur = scene.edgeShade ?? 0;\r\n\r\n        context.rotate(shape.texture.rotate ?? 0);\r\n        const textureScale = texture.scale * (shape.texture.scale || 1);\r\n\r\n        if (shape.stretch) {\r\n            context.translate(...shape.vertices[0]);\r\n\r\n            const vector: Point = subtract(shape.vertices[1], shape.vertices[0]);\r\n\r\n            const stretchWidth = lineLength(vector);\r\n            const stretchHeight = lineLength(subtract(shape.vertices[2], shape.vertices[1]));\r\n\r\n            const angle = Math.atan2(vector[1], vector[0]);\r\n            context.rotate(angle);\r\n\r\n            const imageScale: Point = [textureScale / texture.loadedImage.width, textureScale / texture.loadedImage.height];\r\n            //const imageScale: Point = [textureScale / Math.max(texture.loadedImage.width, texture.loadedImage.height), textureScale / Math.max(texture.loadedImage.width, texture.loadedImage.height)];\r\n            context.scale(...imageScale);\r\n            context.scale(stretchWidth, stretchHeight);\r\n            context.scale(1.2, 1.2)\r\n            context.drawImage(texture.loadedImage, - texture.loadedImage.width / 10, - texture.loadedImage.height / 10);\r\n        } else {\r\n            const imageScale: Point = [textureScale / texture.loadedImage.width, textureScale / texture.loadedImage.height];\r\n            context.save();\r\n            context.scale(...imageScale);\r\n\r\n            context.fillStyle = context.createPattern(texture.loadedImage, 'repeat') || '#c0c';\r\n            context.fill();\r\n            context.restore();\r\n\r\n            drawPath(borderArea(shape, -0.05));\r\n            context.scale(...imageScale);\r\n            context.fillStyle = context.createPattern(texture.transparentImage, 'repeat') || '#c0c';\r\n            context.fill();\r\n\r\n        }\r\n\r\n\r\n        if (debug) {\r\n            context.strokeStyle = 'rgba(255, 255, 0, 1)';\r\n            context.lineWidth = 20;\r\n            context.stroke();\r\n        }\r\n    }\r\n\r\n    const sceneObject = (shape: SceneObject, shadowDirection: Point) => {\r\n        reset();\r\n        const texture = textures[shape.texture.name];\r\n        const textureScale = texture.scale * (shape.texture.scale || 1);\r\n\r\n        context.moveTo(...shape.origin);\r\n\r\n        context.translate(...shape.origin);\r\n        context.rotate((shape.texture.rotate ?? 0) + shape.orientation);\r\n\r\n        const imageScale: Point = [textureScale / texture.loadedImage.naturalWidth, textureScale / texture.loadedImage.naturalHeight];\r\n\r\n        context.scale(...imageScale);\r\n\r\n        //TODO: debug why this fucks up everything\r\n        // context.fillStyle = '#cfc';\r\n        // context.fill();\r\n\r\n        const shadowVector = stretch(shadowDirection, shape.height ?? 0);\r\n        context.shadowColor = 'rgba(30, 30, 30, .9)';\r\n        context.shadowOffsetX = shadowVector[0];\r\n        context.shadowOffsetY = shadowVector[1];\r\n        context.shadowBlur = 2;\r\n\r\n        context.drawImage(texture.loadedImage, -texture.loadedImage.naturalWidth / 2, -texture.loadedImage.naturalHeight / 2);\r\n\r\n        if (debug) {\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n            // fix this\r\n            // context.fillStyle = 'rgba(0, 0, 255, .2)';\r\n            // context.fillRect(-1 / 2, -1 / 2, 1, 1);\r\n            debugPoint(shape.origin);\r\n            context.arc(...shape.origin, shape.radius, 0, Math.PI * 2);\r\n            context.fillStyle = 'rgba(255, 0, 0, .2)';\r\n            context.fill();\r\n        }\r\n    }\r\n\r\n\r\n    const drawScene = () => {\r\n        context.clearRect(0, 0, context.canvas.width, context.canvas.height);\r\n        console.log(scene);\r\n        Object.values(scene.layers).forEach(layer => {\r\n            layer.areas?.sort((a, b) => (a.stretch ? 1 : 0) - (b.stretch ? 1 : 0)).forEach(sceneArea);\r\n            layer.objects?.forEach(ob => sceneObject(ob, scene.shadowVector));\r\n        });\r\n        if (scene.tint && scene.tint !== 'none') {\r\n            reset();\r\n            context.fillStyle = scene.tint;\r\n            context.setTransform(new DOMMatrix());\r\n            context.fillRect(0, 0, context.canvas.width, context.canvas.height);\r\n        }\r\n        reset();\r\n        context.setTransform(new DOMMatrix());\r\n        context.beginPath();\r\n        for (let x = 0; x < scene.size[0]; x++) {\r\n            context.moveTo(globalScale[0] * x, 0);\r\n            context.lineTo(globalScale[0] * x, context.canvas.height);\r\n        }\r\n        for (let y = 0; y < scene.size[1]; y++) {\r\n            context.moveTo(0, y * globalScale[1]);\r\n            context.lineTo(context.canvas.width, y * globalScale[1]);\r\n        }\r\n        context.strokeStyle = 'black';\r\n        context.lineWidth = 1;\r\n        context.stroke();\r\n    }\r\n\r\n    drawScene();\r\n}","export const randomInt = (max: number) => {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\r\nexport const randomPlusMinus = (max: number) => {\r\n    return randomBetween(-max, max);\r\n}\r\n\r\nexport const randomBetween = (from: number, to: number) => {\r\n    return from + Math.random() * (to - from);\r\n}","import { randomBetween, randomInt, randomPlusMinus } from \"../Random\";\r\nimport { SceneArea, SceneTexture } from \"../Scene\";\r\nimport { Point, lineLength, lineNormal, add, stretch, invert, relative, intersection, subtract } from \"../Vector\";\r\n\r\nconst SPLIT_MIN = 0.2;\r\nconst SPLIT_MAX = 0.8;\r\nconst BENDINESS = 1 / 10;\r\nconst SPLITS = 1000;\r\nconst MINIMUM_SPLIT_LENGTH = 0.01;\r\n\r\nconst splitLine = (from: Point, to: Point): Point | null => {\r\n    const splitRatio = randomBetween(SPLIT_MIN, SPLIT_MAX);\r\n    const length = lineLength(from, to);\r\n    if (length < MINIMUM_SPLIT_LENGTH) {\r\n        return null;\r\n    }\r\n    const lineVector = relative(from, to);\r\n    const splitPoint = add(from, stretch(lineVector, splitRatio));\r\n\r\n    const normal = lineNormal(from, to);\r\n    const perturbation = stretch(normal, randomPlusMinus(length * BENDINESS));\r\n\r\n    return add(splitPoint, perturbation);\r\n}\r\n\r\nconst intersect = (line: [Point, Point], area: SceneArea): Array<number> => {\r\n    const ret: Array<number> = [];\r\n    for (let i = 0; i < area.vertices.length; i++) {\r\n        const p1 = area.vertices[i];\r\n        const p2 = area.vertices[(i + 1) % area.vertices.length];\r\n        const fraction = intersection(line, [p1, p2]);\r\n        if (fraction !== null) {\r\n            ret.push(fraction);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nconst createRectangle = (from: Point, to: Point, width: number, texture: SceneTexture): SceneArea => {\r\n    const widthAdjustment = stretch(lineNormal(from, to), width / 2);\r\n    const centerline: Array<Point> = [from, to];\r\n    const topLine: Array<Point> = centerline.map(vertex => add(vertex, invert(widthAdjustment)));\r\n    const bottomLine: Array<Point> = centerline.reverse().map(vertex => add(vertex, widthAdjustment));\r\n    return {\r\n        vertices: [...topLine, ...bottomLine],\r\n        texture,\r\n        stretch: true\r\n    };\r\n}\r\n\r\nconst generateRoad = (from: Point, to: Point, width: number, texture: SceneTexture, bridgeTexture?: SceneTexture, river?: SceneArea): Array<SceneArea> => {\r\n    const widthAdjustment = stretch(lineNormal(from, to), width / 2);\r\n\r\n    const centerline: Array<Point> = [from, to];\r\n\r\n    if (river && bridgeTexture) {\r\n        const intersectionPoints = intersect(centerline as [Point, Point], river);\r\n        intersectionPoints.sort((a, b) => a - b);\r\n        if (intersectionPoints.length === 2) {\r\n            const bridge1 = add(from, stretch(subtract(to, from), intersectionPoints[0]));\r\n            const bridge2 = add(from, stretch(subtract(to, from), intersectionPoints[1]));\r\n            return [\r\n                ...generateRoad(from, bridge1, width, texture),\r\n                ...generateRoad(bridge2, to, width, texture),\r\n                createRectangle(bridge1, bridge2, width, bridgeTexture)\r\n            ];\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < SPLITS; i++) {\r\n        const idx = randomInt(centerline.length - 1) + 1;\r\n        const split = splitLine(centerline[idx - 1], centerline[idx]);\r\n        if (split) {\r\n            centerline.splice(idx, 0, split);\r\n        }\r\n    }\r\n\r\n    const topLine: Array<Point> = centerline.map(vertex => add(vertex, invert(widthAdjustment)));\r\n    const bottomLine: Array<Point> = centerline.reverse().map(vertex => add(vertex, widthAdjustment));\r\n    return [{\r\n        vertices: [...topLine, ...bottomLine],\r\n        texture\r\n    }];\r\n}\r\n\r\nconst generateRoads = (endpoints: Array<{ from: Point, width: number }>, texture: SceneTexture, bridgeTexture?: SceneTexture, river?: SceneArea): Array<SceneArea> => {\r\n    if (endpoints.length > 2) {\r\n        const midpoint = endpoints.reduce((acc, curr) => [acc[0] + curr.from[0] / endpoints.length, acc[1] + curr.from[1] / endpoints.length] as Point, [0, 0] as Point);\r\n        return endpoints.flatMap(ep => generateRoad(ep.from, midpoint, ep.width, texture, bridgeTexture, river));\r\n    } else {\r\n        return generateRoad(endpoints[0].from, endpoints[1].from, endpoints[0].width, texture, bridgeTexture, river);\r\n    }\r\n\r\n}\r\n\r\n\r\nexport const Road = {\r\n    generate: generateRoads,\r\n}\r\n\r\n\r\n","import { randomBetween } from \"../Random\";\r\nimport { SceneArea, SceneObject, SceneTexture } from \"../Scene\";\r\nimport { Point, lineLength } from \"../Vector\";\r\n\r\ndeclare const OffscreenCanvas: any;\r\n\r\nconst MAX_TRIES = 1000;\r\n\r\nconst placeObject = (dim: Point, avoid: Array<SceneObject>, radius: number, tries: number): Point | null => {\r\n    let tried = 0;\r\n    while (tried++ < tries) {\r\n        const candidate: Point = [randomBetween(0, dim[0]), randomBetween(0, dim[1])];\r\n        const farEnough = avoid.every(ob => lineLength(ob.origin, candidate) > radius + ob.radius);\r\n        if (farEnough) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nconst spreadObjects = (dim: Point, avoid: Array<SceneObject>, count: number, height: number, radius: number, texture: SceneTexture): Array<SceneObject> => {\r\n\r\n    let ret: Array<SceneObject> = [];\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const newPoint = placeObject(dim, ret.concat(avoid), radius, MAX_TRIES);\r\n        if (newPoint === null) {\r\n            console.warn(`stopped object generation at ${i}, too many tries`);\r\n            break;\r\n        }\r\n        ret.push({\r\n            origin: newPoint,\r\n            orientation: randomBetween(0, 2 * Math.PI),\r\n            height,\r\n            radius,\r\n            texture\r\n        });\r\n    }\r\n    return ret;\r\n}\r\n\r\nconst inShapeFactory = (shape: SceneArea): ((point: Point) => boolean) => {\r\n\r\n    const canvas = new OffscreenCanvas(1, 1);\r\n    const context = canvas.getContext('2d') as unknown as CanvasRenderingContext2D;\r\n\r\n    const path: Path2D = new Path2D();\r\n    path.moveTo(...shape.vertices[0]);\r\n    shape.vertices.slice(1).forEach(vertex => {\r\n        path.lineTo(...vertex);\r\n    });\r\n    path.closePath();\r\n    return point => context.isPointInPath(path, ...point);\r\n}\r\n\r\nexport const SceneObjects = {\r\n    generate: (dim: Point, avoid: Array<SceneObject>, count: number, height: number, radius: number, texture: SceneTexture, exclude: Array<SceneArea> = []): Array<SceneObject> => {\r\n        const shapeChecker = exclude.map(inShapeFactory);\r\n\r\n        return spreadObjects(dim, avoid, count, height, radius, texture).filter(ob => shapeChecker.every(sc => !sc(ob.origin)));\r\n    }\r\n\r\n}","import { randomBetween, randomInt } from \"./Random\";\r\nimport { Scene, SceneArea, SceneObject, SceneTexture } from \"./Scene\";\r\nimport { Point } from \"./Vector\";\r\nimport { Road } from \"./generators/Road\";\r\nimport { SceneObjects } from \"./generators/SceneObjects\";\r\nimport { Texture } from \"./Textures\";\r\n\r\n\r\nconst ROAD_EDGE_OVERHANG = 2;\r\n\r\nconst randomEdgePoint = (dim: Point): Point => {\r\n    const side = randomInt(4);\r\n    const chosenDim = dim[side % 2]; // width if side is even, height if side is odd;\r\n    const pos = randomBetween(chosenDim * 0.1, chosenDim * 0.9);\r\n\r\n    switch (side) {\r\n        case 0: return [pos, -ROAD_EDGE_OVERHANG];\r\n        case 1: return [dim[0] + ROAD_EDGE_OVERHANG, pos];\r\n        case 2: return [pos, dim[1] + ROAD_EDGE_OVERHANG];\r\n        case 3: return [-ROAD_EDGE_OVERHANG, pos];\r\n        default: throw new Error('randomInt(4) returned a weird value');\r\n    }\r\n}\r\n\r\nexport const SceneGenerator = {\r\n    create: (dim: Point, baseTexture: string): Scene => ({\r\n        layers: {\r\n            base: {\r\n                areas: [{\r\n                    vertices: [[0, 0], [dim[0], 0], dim, [0, dim[1]]],\r\n                    texture: {\r\n                        name: baseTexture,\r\n                    },\r\n                }],\r\n                type: 'base'\r\n            }\r\n        },\r\n        shadowVector: [0, 0],\r\n        size: dim\r\n    }),\r\n    river: (scene: Scene, layer: string, mainWidth: number, texture: Texture): Scene => {\r\n        const dim = scene.size;\r\n\r\n        const mainEndpoints: Array<{ from: Point, width: number }> = [\r\n            { from: [randomBetween(0.1 * dim[0], 0.9 * dim[0]), -ROAD_EDGE_OVERHANG], width: mainWidth },\r\n            { from: [randomBetween(0.1 * dim[0], 0.9 * dim[0]), dim[1] + ROAD_EDGE_OVERHANG], width: mainWidth }\r\n        ];\r\n\r\n        scene.layers[layer] = {\r\n            areas: Road.generate(mainEndpoints, {\r\n                name: texture.name\r\n            }),\r\n            type: 'river'\r\n        };\r\n\r\n        return scene;\r\n    },\r\n    roads: (scene: Scene, layer: string, mainWidth: number, sideRoads: Array<number>, texture: Texture, bridgeTexture?: Texture, river?: SceneArea): Scene => {\r\n        const dim = scene.size;\r\n\r\n        let mainEndpoints: Array<{ from: Point, width: number }> = [\r\n            { from: [-ROAD_EDGE_OVERHANG, randomBetween(0.1 * dim[1], 0.9 * dim[1])], width: mainWidth },\r\n            { from: [dim[0] + ROAD_EDGE_OVERHANG, randomBetween(0.1 * dim[1], 0.9 * dim[1])], width: mainWidth }\r\n        ];\r\n\r\n        const extraEndpoints = sideRoads.map(width => ({\r\n            from: randomEdgePoint(dim),\r\n            width: width\r\n        }));\r\n\r\n        const bridge: SceneTexture | undefined = bridgeTexture && {\r\n            name: bridgeTexture.name\r\n        };\r\n\r\n        scene.layers[layer] = {\r\n            areas: Road.generate([...mainEndpoints, ...extraEndpoints], {\r\n                name: texture.name\r\n            },\r\n                bridge,\r\n                river),\r\n            type: 'road'\r\n        };\r\n\r\n        return scene;\r\n    },\r\n    objects: (scene: Scene, layer: string, count: number, texture: Texture): Scene => {\r\n        const currentObjects: Array<SceneObject> = scene.layers[layer]?.objects ?? [];\r\n        const roadAreas: Array<SceneArea> = [...scene.layers.road.areas ?? [], ...scene.layers.river.areas ?? []];\r\n        const newObjects = SceneObjects.generate(scene.size, currentObjects, count, texture.height, texture.radius, {\r\n            name: texture.name,\r\n        }, roadAreas);\r\n        scene.layers[layer] = {\r\n            objects: currentObjects.concat(newObjects),\r\n            type: 'object'\r\n        }\r\n        return scene;\r\n    }\r\n}\r\n","export default __webpack_public_path__ + \"static/media/gravel.fadd9e77.jpg\";","export default __webpack_public_path__ + \"static/media/grass.1bdb8368.jpg\";","export default __webpack_public_path__ + \"static/media/tree.251e1382.png\";","export default __webpack_public_path__ + \"static/media/tree2.b70d7e22.png\";","export default __webpack_public_path__ + \"static/media/rock.f8863753.png\";","export default __webpack_public_path__ + \"static/media/dirtroad.3f84b32a.jpg\";","export default __webpack_public_path__ + \"static/media/lightergrass.775fd4e3.jpg\";","export default __webpack_public_path__ + \"static/media/water.5bcc6117.jpg\";","export default __webpack_public_path__ + \"static/media/bridge.01e94610.png\";","export default __webpack_public_path__ + \"static/media/bridge2.c503a7ba.png\";","import React, { useEffect, useReducer } from 'react';\r\n\r\nimport gravel from './textures/gravel.jpg';\r\nimport grass from './textures/grass.jpg';\r\nimport tree from './textures/tree.png';\r\nimport tree2 from './textures/tree2.png';\r\nimport rock from './textures/rock.png';\r\nimport dirt from './textures/dirtroad.jpg';\r\nimport lighterGrass from './textures/lightergrass.jpg';\r\nimport water from './textures/water.jpg';\r\nimport bridge from './textures/bridge.png';\r\nimport bridge2 from './textures/bridge2.png';\r\n\r\nexport interface Texture {\r\n    name: string;\r\n    category: TextureCategory;\r\n    url: string;\r\n    type: 'single' | 'pattern';\r\n    scale: number;\r\n    height: number;\r\n    radius: number;\r\n    loadedImage: HTMLImageElement;\r\n    transparentImage: HTMLImageElement;\r\n}\r\n\r\nexport const TINTS: Record<string, string> = {\r\n    sunset: 'rgba(230,120,0,0.15)',\r\n    evening: 'rgba(0,0,250,0.2)',\r\n    night: 'rgba(0,0,250,0.3)',\r\n}\r\n\r\nexport type TextureCategory = 'ground' | 'river' | 'road' | 'bridge' | 'tree' | 'rock';\r\n\r\nexport const TEXTURES: Array<Omit<Texture, 'loadedImage' | 'transparentImage'>> = [\r\n    {\r\n        name: 'water',\r\n        url: water,\r\n        type: 'pattern',\r\n        scale: 1,\r\n        category: 'river',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'bridge',\r\n        url: bridge,\r\n        type: 'pattern',\r\n        scale: 1,\r\n        category: 'bridge',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'straight bridge',\r\n        url: bridge2,\r\n        type: 'pattern',\r\n        scale: 1,\r\n        category: 'bridge',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'gravel',\r\n        url: gravel,\r\n        type: 'pattern',\r\n        scale: 1,\r\n        category: 'road',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'dirt',\r\n        url: dirt,\r\n        type: 'pattern',\r\n        scale: 1,\r\n        category: 'road',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'grass',\r\n        url: grass,\r\n        type: 'pattern',\r\n        scale: 3,\r\n        category: 'ground',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'lighter grass',\r\n        url: lighterGrass,\r\n        type: 'pattern',\r\n        scale: 1,\r\n        category: 'ground',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'tree',\r\n        url: tree,\r\n        type: 'single',\r\n        scale: 2,\r\n        category: 'tree',\r\n        height: 8,\r\n        radius: 1,\r\n    },\r\n    {\r\n        name: 'bigtree',\r\n        url: tree,\r\n        type: 'single',\r\n        scale: 4,\r\n        category: 'tree',\r\n        height: 16,\r\n        radius: 2,\r\n    },\r\n    {\r\n        name: 'other tree',\r\n        url: tree2,\r\n        type: 'single',\r\n        scale: 3,\r\n        category: 'tree',\r\n        height: 12,\r\n        radius: 1.5,\r\n    },\r\n    {\r\n        name: 'rock',\r\n        url: rock,\r\n        type: 'single',\r\n        scale: 0.3,\r\n        category: 'rock',\r\n        height: 2,\r\n        radius: 0.25,\r\n    },\r\n]\r\n\r\ndeclare const OffscreenCanvas: any;\r\n\r\nconst makeImageTransparent = async (image: HTMLImageElement): Promise<HTMLImageElement> => {\r\n    const offscreen = new OffscreenCanvas(image.naturalWidth, image.naturalHeight);\r\n    const osContext = offscreen.getContext('2d') as CanvasRenderingContext2D;\r\n    osContext.drawImage(image, 0, 0);\r\n    const imageData = osContext.getImageData(0, 0, image.naturalWidth, image.naturalHeight);\r\n    for (let i = 3; i < imageData.data.length; i += 4) {\r\n        if (i === 3) {\r\n            console.log('alpha', image.src, imageData.data[i]);\r\n        }\r\n        imageData.data.set([imageData.data[i] / 3], i);\r\n    }\r\n    osContext.putImageData(imageData, 0, 0);\r\n    const output = new Image();\r\n\r\n    const blob = await offscreen.convertToBlob({\r\n        type: \"image/png\",\r\n    });\r\n\r\n    output.src = URL.createObjectURL(blob); // use toDataURL() to avoid cleanup problems\r\n    return output;\r\n}\r\n\r\n\r\nexport const Textures: React.FC<{ onLoaded: (textures: Array<Texture>) => unknown }> = ({ onLoaded }) => {\r\n\r\n    const [imagesLoaded, imageLoaded] = useReducer((prevstate: number, action: {}) => {\r\n        return prevstate + 1;\r\n    }, 0);\r\n\r\n    useEffect(() => {\r\n        if (imagesLoaded === TEXTURES.length) {\r\n            (async () => {\r\n                const loaded: Array<Texture> = [];\r\n                for (let i = 0; i < TEXTURES.length; i++) {\r\n                    const t = TEXTURES[i];\r\n                    const loadedImage = document.getElementById(t.name) as HTMLImageElement;\r\n                    const transparentImage = await makeImageTransparent(loadedImage);\r\n                    loaded.push({ ...t, loadedImage, transparentImage });\r\n                }\r\n                onLoaded(loaded);\r\n\r\n            })();\r\n        }\r\n    }, [imagesLoaded, onLoaded]);\r\n\r\n    return <>\r\n        {TEXTURES.map(t => <img key={t.name} src={t.url} id={t.name} style={{ display: 'none' }} alt='' onLoad={imageLoaded} />)}\r\n    </>;\r\n}","import React from 'react';\r\nimport { Select } from 'semantic-ui-react';\r\nimport { Texture, TextureCategory } from './Textures';\r\n\r\nexport interface TextureSelectorProps {\r\n    textures: Record<string, Texture>,\r\n    type: 'single' | 'pattern',\r\n    category?: TextureCategory,\r\n    value: string,\r\n    onChange: (name: string) => unknown,\r\n}\r\n\r\nexport const TextureSelector: React.FC<TextureSelectorProps> = ({ textures, type, category, value, onChange }) => {\r\n    return <Select\r\n        value={value}\r\n        onChange={(_, { value }) => onChange(value as string)}\r\n        placeholder='Select texture'\r\n        options={\r\n            Object.keys(textures)\r\n                .filter(t => textures[t].type === type)\r\n                .filter(t => !category || (textures[t].category === category))\r\n                .map(t => ({ key: t, text: t, value: t, image: textures[t].url }))\r\n        }\r\n    />\r\n}","import React, { useState } from 'react';\r\nimport { Button, ButtonGroup, Card, Header, Input } from 'semantic-ui-react';\r\nimport { Texture } from './Textures';\r\nimport { TextureSelector } from './TextureSelector';\r\n\r\nexport interface ObjectLayerCardProps {\r\n    name: string;\r\n    textures: Record<string, Texture>;\r\n    generateObjects: (count: number, texture: string) => unknown;\r\n    clearLayer: () => unknown;\r\n    deleteLayer: () => unknown;\r\n}\r\n\r\n\r\nexport const ObjectLayerCard: React.FC<ObjectLayerCardProps> = ({ name, textures, generateObjects, clearLayer, deleteLayer }) => {\r\n    const [count, setCount] = useState<number>(0);\r\n    const [texture, setTexture] = useState<string>('');\r\n\r\n    return <Card>\r\n        <Card.Header><Header textAlign='center'>Object layer: {name}</Header></Card.Header>\r\n        <Card.Content>\r\n            <Input type='number' label='No. of objects:' value={count} step={1} onChange={e => setCount(Number(e.target.value))} />\r\n            <TextureSelector value={texture} textures={textures ?? {}} type='single' onChange={setTexture} />\r\n            <ButtonGroup>\r\n                <Button content='Add' icon='plus' disabled={count === 0 || texture === ''} onClick={() => generateObjects(count, texture)} />\r\n                <Button content='Clear' icon='eraser' onClick={clearLayer} />\r\n                <Button content='Remove' icon='remove' onClick={deleteLayer} />\r\n            </ButtonGroup>\r\n        </Card.Content>\r\n    </Card>\r\n}","import React, { useState } from 'react';\r\nimport { Button, Card, Header, Input } from 'semantic-ui-react';\r\n\r\nexport interface CreateLayerCardProps {\r\n    layers: Array<string>;\r\n    onCreate: (name: string) => unknown;\r\n}\r\n\r\n\r\nexport const CreateLayerCard: React.FC<CreateLayerCardProps> = ({ layers, onCreate }) => {\r\n    const [name, setName] = useState<string>('');\r\n\r\n    return <Card>\r\n        <Card.Header><Header textAlign='center'>Add new layer</Header></Card.Header>\r\n        <Card.Content>\r\n            <Input label='Layer name' value={name} onChange={e => setName(e.target.value)} />\r\n            <Button\r\n                icon='clone outline'\r\n                content='Create'\r\n                disabled={name === '' || layers.includes(name)}\r\n                onClick={() => {\r\n                    onCreate(name);\r\n                    setName('');\r\n                }} />\r\n        </Card.Content>\r\n    </Card>\r\n}","import { range } from 'lodash';\r\nimport React from 'react';\r\nimport { Button, List, SemanticICONS } from 'semantic-ui-react';\r\n\r\nexport interface ListComponentProps {\r\n    items: number;\r\n    itemFactory: (index: number) => JSX.Element;\r\n    addItem: () => unknown;\r\n    removeItem: (index: number) => unknown;\r\n    itemIcon?: SemanticICONS;\r\n    name: string;\r\n}\r\n\r\nexport const ListComponent: React.FC<ListComponentProps> = ({ items, itemFactory, addItem, removeItem, itemIcon, name }) => {\r\n    return <List divided relaxed>\r\n        {range(0, items).map(index => <List.Item>\r\n            {itemIcon && <List.Icon name={itemIcon} />}\r\n            <List.Content>\r\n                {itemFactory(index)} <Button floated='right' icon='remove' onClick={() => removeItem(index)} />\r\n            </List.Content>\r\n        </List.Item>)}\r\n        <List.Item>\r\n            <List.Content>\r\n                <Button icon='plus' content={`Add ${name}`} onClick={addItem} />\r\n            </List.Content>\r\n        </List.Item>\r\n    </List>;\r\n}","import React, { useState } from 'react';\r\nimport { Button, Card, Header, Input } from 'semantic-ui-react';\r\nimport { ListComponent } from './ListComponent';\r\nimport { Texture } from './Textures';\r\nimport { TextureSelector } from './TextureSelector';\r\n\r\nexport interface RoadLayerCardProps {\r\n    name: string;\r\n    textures: Record<string, Texture>;\r\n    sceneHasRiver: boolean;\r\n    generateRoads: (mainWidth: number, sideRoads: Array<number>, texture: string, bridgeTexture?: string) => unknown;\r\n}\r\n\r\n\r\nexport const RoadLayerCard: React.FC<RoadLayerCardProps> = ({ name, textures, generateRoads, sceneHasRiver }) => {\r\n    const [mainWidth, setMainWidth] = useState<number>(0);\r\n    const [texture, setTexture] = useState<string>('');\r\n    const [bridgeTexture, setBridgeTexture] = useState<string>('');\r\n    const [sideRoads, setSideRoads] = useState<Array<number>>([]);\r\n\r\n    return <Card>\r\n        <Card.Header><Header textAlign='center'>Road Layer</Header></Card.Header>\r\n        <Card.Content>\r\n            <Input label='Main road width:' type='number' value={mainWidth} onChange={e => setMainWidth(Number(e.target.value))} />\r\n            <TextureSelector value={texture} textures={textures ?? {}} category='road' type='pattern' onChange={setTexture} />\r\n            {sceneHasRiver && <TextureSelector value={bridgeTexture} textures={textures ?? {}} category='bridge' type='pattern' onChange={setBridgeTexture} />}\r\n            <ListComponent\r\n                items={sideRoads.length}\r\n                name='side road'\r\n                itemIcon='road'\r\n                addItem={() => {\r\n                    setSideRoads([...sideRoads, 0]);\r\n                }}\r\n                removeItem={index => {\r\n                    sideRoads.splice(index, 1);\r\n                    setSideRoads([...sideRoads]);\r\n                }}\r\n                itemFactory={index => <Input label='Side road width:' type='number' value={sideRoads[index]} onChange={e => { sideRoads[index] = Number(e.target.value); setSideRoads([...sideRoads]); }} />} />\r\n            <Button icon='redo' content='Generate' disabled={texture === ''} onClick={() => generateRoads(mainWidth, sideRoads, texture, bridgeTexture)} />\r\n        </Card.Content>\r\n    </Card>\r\n}","import React from 'react';\r\nimport { Card, Header, Input, Select } from 'semantic-ui-react';\r\nimport { TINTS } from './Textures';\r\nimport { fromPolar, lineLength, Point } from './Vector';\r\n\r\nexport interface VisualsCardProps {\r\n    shadowVector: Point;\r\n    onShadowChange: (shadowVector: Point) => unknown;\r\n    tint: string;\r\n    onTintChange: (tint: string) => unknown;\r\n    resolution: number;\r\n    onResolutionChange: (resolution: number) => unknown;\r\n    edgeShade?: number;\r\n    onEdgeShadeChange: (edgeShade: number) => unknown;\r\n}\r\n\r\n\r\nexport const VisualsCard: React.FC<VisualsCardProps> = ({ tint, shadowVector, onShadowChange, onTintChange, resolution, onResolutionChange, edgeShade, onEdgeShadeChange }) => {\r\n    const shadowLength = Math.round(lineLength(shadowVector) * 10);\r\n    const shadowAngle = Math.round(Math.atan2(shadowVector[1], shadowVector[0]) * 180 / Math.PI);\r\n    return <Card>\r\n        <Card.Header><Header textAlign='center'>Visual tweaks</Header></Card.Header>\r\n        <Card.Content>\r\n            <Select value={tint || 'none'} onChange={(_, { value }) => onTintChange(value as string)} options={\r\n                [{ key: '', value: 'none', text: 'no tint' }, ...Object.keys(TINTS).map(t => ({ key: t, value: TINTS[t], text: t }))]\r\n            } />\r\n            <br />\r\n            <Input label='Shadow length' type='number' value={shadowLength} onChange={e => onShadowChange(fromPolar(Number(e.target.value) / 10, Number(shadowAngle) * Math.PI / 180))} />\r\n            <Input label='Shadow direction' type='number' step={5} value={shadowAngle} onChange={e => onShadowChange(fromPolar(shadowLength / 10, Number(e.target.value) * Math.PI / 180))} />\r\n            <Input label='Edge shade' type='number' step={5} value={edgeShade} onChange={e => onEdgeShadeChange(Number(e.target.value))} />\r\n            <Input label='Pixels per grid' type='number' step={5} value={resolution} onChange={e => onResolutionChange(Number(e.target.value))} />\r\n        </Card.Content>\r\n    </Card>\r\n}","import React, { useState } from 'react';\r\nimport { Button, Card, Header, Input } from 'semantic-ui-react';\r\nimport { Texture } from './Textures';\r\nimport { TextureSelector } from './TextureSelector';\r\nimport { Point } from './Vector';\r\n\r\ninterface BaseLayerCardProps {\r\n    textures: Record<string, Texture>;\r\n    createScene: (dimensions: Point, baseTexture: string) => unknown;\r\n}\r\n\r\nexport const BaseLayerCard: React.FC<BaseLayerCardProps> = ({ textures, createScene }) => {\r\n\r\n    const [texture, setTexture] = useState<string>('');\r\n    const [width, setWidth] = useState<number>(10);\r\n    const [height, setHeight] = useState<number>(10);\r\n\r\n    return <Card>\r\n        <Card.Header><Header textAlign='center'>Scene</Header></Card.Header>\r\n        <Card.Content>\r\n            <Input type='number' label='Width' value={width} step={20} onChange={e => setWidth(Number(e.target.value))} />\r\n            <Input type='number' label='Height' value={height} step={20} onChange={e => setHeight(Number(e.target.value))} />\r\n            <TextureSelector value={texture} textures={textures ?? {}} type='pattern' category='ground' onChange={setTexture} />\r\n\r\n            <Button\r\n                icon='clone outline'\r\n                content='Create'\r\n                disabled={texture === ''}\r\n                onClick={() => createScene([width, height], texture)} />\r\n        </Card.Content>\r\n    </Card>\r\n}","import React, { useState } from 'react';\r\nimport { Button, Card, Header, Input } from 'semantic-ui-react';\r\nimport { Texture } from './Textures';\r\nimport { TextureSelector } from './TextureSelector';\r\n\r\nexport interface RiverLayerCardProps {\r\n    name: string;\r\n    textures: Record<string, Texture>;\r\n    generateRiver: (mainWidth: number, texture: string) => unknown;\r\n}\r\n\r\n\r\nexport const RiverLayerCard: React.FC<RiverLayerCardProps> = ({ name, textures, generateRiver }) => {\r\n    const [mainWidth, setMainWidth] = useState<number>(0);\r\n    const [texture, setTexture] = useState<string>('');\r\n\r\n    return <Card>\r\n        <Card.Header><Header textAlign='center'>River Layer</Header></Card.Header>\r\n        <Card.Content>\r\n            <Input label='River width:' type='number' value={mainWidth} onChange={e => setMainWidth(Number(e.target.value))} />\r\n            <TextureSelector value={texture} textures={textures ?? {}} category='river' type='pattern' onChange={setTexture} />\r\n            <Button icon='redo' content='Generate' disabled={texture === ''} onClick={() => generateRiver(mainWidth, texture)} />\r\n        </Card.Content>\r\n    </Card>\r\n}","import React, { useCallback, useEffect, useRef, useState } from 'react';\r\nimport { drawScene } from './ShapeDrawer';\r\nimport { SceneGenerator } from './SceneGenerator';\r\nimport { Point } from './Vector';\r\nimport { Texture, Textures } from './Textures';\r\nimport { Scene } from './Scene';\r\nimport { ObjectLayerCard } from './ObjectLayerCard';\r\nimport { CreateLayerCard } from './CreateLayerCard';\r\nimport { RoadLayerCard } from './RoadLayerCard';\r\nimport { Card, Checkbox } from 'semantic-ui-react';\r\nimport { VisualsCard } from './VisualsCard';\r\nimport { BaseLayerCard } from './BaseLayerCard';\r\nimport { RiverLayerCard } from './RiverLayerCard';\r\n\r\nconst SCALE = 70;\r\n\r\nexport const Canvas: React.FC<{}> = () => {\r\n\r\n    const canvasRef = useRef<HTMLCanvasElement>(null);\r\n    const [textures, setTeztures] = useState<Record<string, Texture>>();\r\n    const [scene, setScene] = useState<Scene>(SceneGenerator.create([10, 10], 'grass'));\r\n    const [resolution, setResolution] = useState<number>(SCALE);\r\n    const [debug, setDebug] = useState<boolean>(false);\r\n\r\n    const regenerateRoads = useCallback((layer: string, mainWidth: number, sideRoads: Array<number>, texture: string, bridgeTexture?: string) => {\r\n        if (textures) {\r\n            setScene({ ...SceneGenerator.roads(scene, layer, mainWidth, sideRoads, textures[texture], textures[bridgeTexture ?? ''], scene.layers.river?.areas?.[0]) });\r\n        }\r\n    }, [scene, textures]);\r\n\r\n    const regenerateRiver = useCallback((layer: string, mainWidth: number, texture: string) => {\r\n        if (textures) {\r\n            setScene({ ...SceneGenerator.river(scene, layer, mainWidth, textures[texture]) });\r\n        }\r\n    }, [scene, textures]);\r\n\r\n\r\n    const clearLayer = useCallback((layer: string) => {\r\n        delete scene.layers?.[layer]?.areas;\r\n        delete scene.layers?.[layer]?.objects;\r\n        setScene({ ...scene });\r\n    }, [scene]);\r\n\r\n    const removeLayer = useCallback((layer: string) => {\r\n        delete scene.layers?.[layer];\r\n        setScene({ ...scene });\r\n    }, [scene]);\r\n\r\n    const createLayer = useCallback((layer: string) => {\r\n        scene.layers[layer] = { type: 'object' };\r\n        setScene({ ...scene });\r\n    }, [scene]);\r\n\r\n    const generateObjects = useCallback((layer: string, count: number, texture: string) => {\r\n        if (textures) {\r\n            SceneGenerator.objects(scene, layer, count, textures[texture]);\r\n        }\r\n        setScene({ ...scene });\r\n    }, [scene, textures]);\r\n\r\n    const createScene = useCallback((dimension: Point, texture: string) => {\r\n        setScene(SceneGenerator.create(dimension, texture));\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        if (textures) {\r\n            const canvas = canvasRef.current;\r\n            if (canvas) {\r\n                const context = canvas.getContext('2d');\r\n                if (context) {\r\n                    drawScene(context, textures, scene, debug);\r\n                }\r\n            }\r\n        }\r\n    }, [textures, scene, resolution, debug]);\r\n\r\n    const onTexturesLoaded = useCallback((textures: Array<Texture>) => {\r\n        const textureMap: Record<string, Texture> = textures.reduce((acc, curr) => { acc[curr.name] = curr; return acc; }, {} as Record<string, Texture>);\r\n        setTeztures(textureMap);\r\n    }, []);\r\n\r\n    return <>\r\n        <Textures onLoaded={onTexturesLoaded} />\r\n        <div style={{ display: 'flex' }}>\r\n            <div>\r\n                <Card.Group itemsPerRow={1}>\r\n                    <BaseLayerCard textures={textures ?? {}} createScene={createScene} />\r\n                    <RiverLayerCard name='river' textures={textures ?? {}} generateRiver={regenerateRiver.bind(null, 'river')} />\r\n                    <RoadLayerCard name='road' sceneHasRiver={!!scene.layers.river} textures={textures ?? {}} generateRoads={regenerateRoads.bind(null, 'road')} />\r\n                    {Object.keys(scene.layers).filter(layer => scene.layers[layer].type === 'object').map(layer => {\r\n                        return <ObjectLayerCard\r\n                            name={layer}\r\n                            textures={textures ?? {}}\r\n                            generateObjects={(count, texture) => generateObjects(layer, count, texture)}\r\n                            clearLayer={() => clearLayer(layer)}\r\n                            deleteLayer={() => removeLayer(layer)}\r\n                        />\r\n                    })}\r\n                    {scene.layers.road && <CreateLayerCard layers={Object.keys(scene.layers)} onCreate={createLayer} />}\r\n\r\n                    <VisualsCard tint={scene.tint ?? ''} shadowVector={scene.shadowVector} onShadowChange={shadow => {\r\n                        scene.shadowVector = shadow;\r\n                        setScene({ ...scene });\r\n                    }}\r\n                        onTintChange={tint => {\r\n                            scene.tint = tint;\r\n                            setScene({ ...scene });\r\n                        }}\r\n                        resolution={resolution}\r\n                        onResolutionChange={setResolution}\r\n                        edgeShade={scene.edgeShade}\r\n                        onEdgeShadeChange={edgeShade => {\r\n                            scene.edgeShade = Math.max(0, edgeShade);\r\n                            setScene({ ...scene });\r\n                        }}\r\n                    />\r\n                    <Card>\r\n                        <Card.Content>\r\n                            <Checkbox label='Debug mode' checked={debug} onChange={(_, data) => setDebug(!debug)} toggle />\r\n                        </Card.Content>\r\n                    </Card>\r\n                </Card.Group>\r\n\r\n            </div>\r\n            <canvas style={{ width: `${scene.size[0] * resolution}px`, height: `${scene.size[1] * resolution}px` }} ref={canvasRef} width={`${scene.size[0] * resolution}px`} height={`${scene.size[1] * resolution}px`} />\r\n        </div>\r\n    </>;\r\n}","import React from 'react';\nimport { Canvas } from './Canvas';\n\nimport 'semantic-ui-css/semantic.min.css'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Canvas />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}