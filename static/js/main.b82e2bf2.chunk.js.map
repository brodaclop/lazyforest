{"version":3,"sources":["Vector.tsx","ShapeDrawer.tsx","Random.tsx","generators/Road.tsx","generators/SceneObjects.tsx","SceneGenerator.tsx","textures/gravel.jpg","textures/grass.jpg","textures/tree.png","textures/tree2.png","textures/rock.png","textures/dirtroad.jpg","textures/lightergrass.jpg","textures/water.jpg","textures/bridge.png","Textures.tsx","TextureSelector.tsx","ObjectLayerCard.tsx","CreateLayerCard.tsx","ListComponent.tsx","RoadLayerCard.tsx","VisualsCard.tsx","BaseLayerCard.tsx","RiverLayerCard.tsx","Canvas.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["lineLength","from","to","Math","sqrt","lineNormal","vector","len","normalize","stretch","length","add","origin","subtract","invert","fromPolar","magnitude","dir","cos","sin","intersection","a","b","vectorA","vectorB","diff","ua_t","ub_t","u_b","ua","ub","console","log","JSON","stringify","window","test","drawScene","context","textures","scene","debug","globalScale","canvas","width","size","height","reset","setTransform","DOMMatrix","shadowOffsetX","shadowOffsetY","shadowColor","shadowBlur","fillStyle","strokeStyle","scale","sceneArea","shape","texture","name","beginPath","moveTo","vertices","slice","forEach","vertex","lineTo","closePath","rotate","textureScale","translate","stretchWidth","stretchHeight","angle","atan2","imageScale","loadedImage","drawImage","createPattern","fill","lineWidth","stroke","sceneObject","shadowDirection","orientation","naturalWidth","naturalHeight","shadowVector","point","style","arc","PI","debugPoint","radius","clearRect","Object","values","layers","layer","areas","sort","objects","ob","tint","fillRect","x","y","randomInt","max","floor","random","randomBetween","splitLine","splitRatio","lineVector","relative","splitPoint","normal","perturbation","createRectangle","widthAdjustment","centerline","topLine","map","bottomLine","reverse","generateRoad","river","intersectionPoints","line","area","ret","i","p1","p2","fraction","push","intersect","bridge1","bridge2","idx","split","splice","Road","endpoints","midpoint","reduce","acc","curr","flatMap","ep","placeObject","dim","avoid","tries","tried","candidate","every","spreadObjects","count","newPoint","concat","warn","inShapeFactory","OffscreenCanvas","getContext","path","Path2D","isPointInPath","SceneObjects","exclude","shapeChecker","filter","sc","randomEdgePoint","side","chosenDim","pos","Error","SceneGenerator","baseTexture","base","type","mainWidth","mainEndpoints","sideRoads","extraEndpoints","currentObjects","roadAreas","road","newObjects","TINTS","sunset","evening","night","TEXTURES","url","water","category","bridge","gravel","dirt","grass","lighterGrass","tree","tree2","rock","Textures","onLoaded","useReducer","prevstate","action","imagesLoaded","imageLoaded","useEffect","t","document","getElementById","src","id","display","alt","onLoad","TextureSelector","value","onChange","Select","_","placeholder","options","keys","key","text","image","ObjectLayerCard","generateObjects","clearLayer","deleteLayer","useState","setCount","setTexture","Card","Header","textAlign","Content","Input","label","step","e","Number","target","ButtonGroup","Button","content","icon","disabled","onClick","CreateLayerCard","onCreate","setName","includes","ListComponent","items","itemFactory","addItem","removeItem","itemIcon","List","divided","relaxed","range","index","Item","Icon","floated","RoadLayerCard","generateRoads","setMainWidth","setSideRoads","VisualsCard","onShadowChange","onTintChange","resolution","onResolutionChange","shadowLength","round","shadowAngle","BaseLayerCard","createScene","setWidth","setHeight","RiverLayerCard","generateRiver","Canvas","canvasRef","useRef","setTeztures","setScene","setResolution","setDebug","regenerateRoads","useCallback","regenerateRiver","removeLayer","createLayer","dimension","current","onTexturesLoaded","textureMap","Group","itemsPerRow","bind","shadow","Checkbox","checked","data","toggle","ref","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.b82e2bf2.chunk.js","sourcesContent":["export type Point = [number, number];\r\n\r\nexport const lineLength = (from: Point, to: Point = [0, 0]): number => Math.sqrt((from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]));\r\n\r\nexport const normalize = (vector: Point): Point => {\r\n    const len = lineLength([0, 0], vector);\r\n    return [vector[0] / len, vector[1] / len];\r\n}\r\n\r\nexport const lineNormal = (from: Point, to: Point): Point => normalize([from[1] - to[1], to[0] - from[0]]);\r\n\r\nexport const stretch = (vector: Point, length: number): Point => [vector[0] * length, vector[1] * length];\r\n\r\nexport const add = (origin: Point, vector: Point): Point => [origin[0] + vector[0], origin[1] + vector[1]];\r\n\r\nexport const subtract = (origin: Point, vector: Point): Point => [origin[0] - vector[0], origin[1] - vector[1]];\r\n\r\nexport const relative = (origin: Point, to: Point): Point => [to[0] - origin[0], to[1] - origin[1]];\r\n\r\nexport const invert = (vector: Point): Point => [-vector[0], -vector[1]];\r\n\r\nexport const fromPolar = (magnitude: number, dir: number): Point => [Math.cos(dir) * magnitude, Math.sin(dir) * magnitude];\r\n\r\nexport const dot = (one: Point, other: Point): number => one[0] * other[0] + one[1] * other[1];\r\n\r\nexport const intersection = (a: [Point, Point], b: [Point, Point]): number | null => {\r\n\r\n    const vectorA = subtract(a[1], a[0]);\r\n    const vectorB = subtract(b[1], b[0]);\r\n    const diff = subtract(a[0], b[0]);\r\n\r\n    const ua_t = vectorB[0] * diff[1] - vectorB[1] * diff[0];\r\n    const ub_t = vectorA[0] * diff[1] - vectorA[1] * diff[0];\r\n    var u_b = vectorB[1] * vectorA[0] - vectorB[0] * vectorA[1];\r\n\r\n    if (u_b !== 0) {\r\n        const ua = ua_t / u_b;\r\n        const ub = ub_t / u_b;\r\n\r\n        console.log(`a: ${JSON.stringify(a)}, b: ${JSON.stringify(b)}, ua: ${ua}, ub: ${ub}`);\r\n\r\n        if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\r\n            return ua;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\ndeclare const window: any;\r\n\r\nwindow.test = intersection;","import { Scene, SceneArea, SceneObject } from \"./Scene\";\r\nimport { Texture } from \"./Textures\";\r\nimport { lineLength, Point, stretch, subtract } from \"./Vector\";\r\n\r\nexport const drawScene = (context: CanvasRenderingContext2D, textures: Record<string, Texture>, scene: Scene, debug?: boolean) => {\r\n\r\n    const globalScale: Point = [context.canvas.width / scene.size[0], context.canvas.height / scene.size[1]];\r\n\r\n    const reset = () => {\r\n        context.setTransform(new DOMMatrix());\r\n        context.shadowOffsetX = 0;\r\n        context.shadowOffsetY = 0;\r\n        context.shadowColor = '';\r\n        context.shadowBlur = 0;\r\n        context.fillStyle = '';\r\n        context.strokeStyle = '';\r\n        context.scale(...globalScale);\r\n    }\r\n\r\n    const debugPoint = (point: Point, style: string = '#0ff') => {\r\n        reset();\r\n        context.beginPath();\r\n        context.moveTo(...point);\r\n        context.strokeStyle = style;\r\n        context.fillStyle = style;\r\n        context.arc(...point, 2 / globalScale[0], 0, 2 * Math.PI);\r\n        context.fill();\r\n        context.closePath();\r\n    }\r\n\r\n\r\n    const sceneArea = (shape: SceneArea) => {\r\n        reset();\r\n\r\n        const texture = textures[shape.texture.name];\r\n\r\n        context.beginPath();\r\n        context.moveTo(...shape.vertices[0]);\r\n        shape.vertices.slice(1).forEach(vertex => {\r\n            context.lineTo(...vertex);\r\n        });\r\n        context.closePath();\r\n\r\n        context.rotate(shape.texture.rotate ?? 0);\r\n\r\n        const textureScale = texture.scale * (shape.texture.scale || 1);\r\n\r\n        if (shape.stretch) {\r\n            context.translate(...shape.vertices[0]);\r\n\r\n            const vector: Point = subtract(shape.vertices[1], shape.vertices[0]);\r\n\r\n            const stretchWidth = lineLength(vector);\r\n            const stretchHeight = lineLength(subtract(shape.vertices[2], shape.vertices[1]));\r\n\r\n            const angle = Math.atan2(vector[1], vector[0]);\r\n            console.log('angle', angle, ...vector);\r\n            context.rotate(angle);\r\n\r\n            const imageScale: Point = [textureScale / texture.loadedImage.width, textureScale / texture.loadedImage.height];\r\n            //const imageScale: Point = [textureScale / Math.max(texture.loadedImage.width, texture.loadedImage.height), textureScale / Math.max(texture.loadedImage.width, texture.loadedImage.height)];\r\n            context.scale(...imageScale);\r\n            context.scale(stretchWidth, stretchHeight);\r\n            context.scale(1.2, 1.2)\r\n            context.drawImage(texture.loadedImage, - texture.loadedImage.width / 10, - texture.loadedImage.height / 10);\r\n        } else {\r\n            const imageScale: Point = [textureScale / texture.loadedImage.width, textureScale / texture.loadedImage.height];\r\n            context.scale(...imageScale);\r\n\r\n            context.fillStyle = context.createPattern(texture.loadedImage, 'repeat') || '#c0c';\r\n            context.fill();\r\n        }\r\n\r\n\r\n        if (debug) {\r\n            context.strokeStyle = 'rgba(255, 255, 0, 1)';\r\n            context.lineWidth = 20;\r\n            context.stroke();\r\n        }\r\n    }\r\n\r\n    const sceneObject = (shape: SceneObject, shadowDirection: Point) => {\r\n        reset();\r\n        const texture = textures[shape.texture.name];\r\n        const textureScale = texture.scale * (shape.texture.scale || 1);\r\n\r\n        context.moveTo(...shape.origin);\r\n\r\n        context.translate(...shape.origin);\r\n        context.rotate((shape.texture.rotate ?? 0) + shape.orientation);\r\n\r\n        const imageScale: Point = [textureScale / texture.loadedImage.naturalWidth, textureScale / texture.loadedImage.naturalHeight];\r\n\r\n        context.scale(...imageScale);\r\n\r\n        //TODO: debug why this fucks up everything\r\n        // context.fillStyle = '#cfc';\r\n        // context.fill();\r\n\r\n        const shadowVector = stretch(shadowDirection, shape.height ?? 0);\r\n        context.shadowColor = 'rgba(30, 30, 30, .9)';\r\n        context.shadowOffsetX = shadowVector[0];\r\n        context.shadowOffsetY = shadowVector[1];\r\n        context.shadowBlur = 2;\r\n\r\n        context.drawImage(texture.loadedImage, -texture.loadedImage.naturalWidth / 2, -texture.loadedImage.naturalHeight / 2);\r\n\r\n        if (debug) {\r\n            context.shadowOffsetX = 0;\r\n            context.shadowOffsetY = 0;\r\n            // fix this\r\n            // context.fillStyle = 'rgba(0, 0, 255, .2)';\r\n            // context.fillRect(-1 / 2, -1 / 2, 1, 1);\r\n            debugPoint(shape.origin);\r\n            context.arc(...shape.origin, shape.radius / 2, 0, Math.PI * 2);\r\n            context.fillStyle = 'rgba(255, 0, 0, .2)';\r\n            context.fill();\r\n        }\r\n    }\r\n\r\n\r\n    const drawScene = () => {\r\n        context.clearRect(0, 0, context.canvas.width, context.canvas.height);\r\n        console.log(scene);\r\n        Object.values(scene.layers).forEach(layer => {\r\n            layer.areas?.sort((a, b) => (a.stretch ? 1 : 0) - (b.stretch ? 1 : 0)).forEach(sceneArea);\r\n            layer.objects?.forEach(ob => sceneObject(ob, scene.shadowVector));\r\n        });\r\n        if (scene.tint && scene.tint !== 'none') {\r\n            reset();\r\n            context.fillStyle = scene.tint;\r\n            context.setTransform(new DOMMatrix());\r\n            context.fillRect(0, 0, context.canvas.width, context.canvas.height);\r\n        }\r\n        reset();\r\n        context.setTransform(new DOMMatrix());\r\n        context.beginPath();\r\n        for (let x = 0; x < scene.size[0]; x++) {\r\n            context.moveTo(globalScale[0] * x, 0);\r\n            context.lineTo(globalScale[0] * x, context.canvas.height);\r\n        }\r\n        for (let y = 0; y < scene.size[1]; y++) {\r\n            context.moveTo(0, y * globalScale[1]);\r\n            context.lineTo(context.canvas.width, y * globalScale[1]);\r\n        }\r\n        context.strokeStyle = 'black';\r\n        context.lineWidth = 1;\r\n        context.stroke();\r\n    }\r\n\r\n    drawScene();\r\n}","export const randomInt = (max: number) => {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\r\nexport const randomPlusMinus = (max: number) => {\r\n    return randomBetween(-max, max);\r\n}\r\n\r\nexport const randomBetween = (from: number, to: number) => {\r\n    return from + Math.random() * (to - from);\r\n}","import { randomBetween, randomInt, randomPlusMinus } from \"../Random\";\r\nimport { SceneArea, SceneTexture } from \"../Scene\";\r\nimport { Point, lineLength, lineNormal, add, stretch, invert, relative, intersection, subtract } from \"../Vector\";\r\n\r\nconst SPLIT_MIN = 0.2;\r\nconst SPLIT_MAX = 0.8;\r\nconst BENDINESS = 1 / 10;\r\nconst SPLITS = 1000;\r\nconst MINIMUM_SPLIT_LENGTH = 0.01;\r\n\r\nconst splitLine = (from: Point, to: Point): Point | null => {\r\n    const splitRatio = randomBetween(SPLIT_MIN, SPLIT_MAX);\r\n    const length = lineLength(from, to);\r\n    if (length < MINIMUM_SPLIT_LENGTH) {\r\n        return null;\r\n    }\r\n    const lineVector = relative(from, to);\r\n    const splitPoint = add(from, stretch(lineVector, splitRatio));\r\n\r\n    const normal = lineNormal(from, to);\r\n    const perturbation = stretch(normal, randomPlusMinus(length * BENDINESS));\r\n\r\n    return add(splitPoint, perturbation);\r\n}\r\n\r\nconst intersect = (line: [Point, Point], area: SceneArea): Array<number> => {\r\n    const ret: Array<number> = [];\r\n    for (let i = 0; i < area.vertices.length; i++) {\r\n        const p1 = area.vertices[i];\r\n        const p2 = area.vertices[(i + 1) % area.vertices.length];\r\n        const fraction = intersection(line, [p1, p2]);\r\n        if (fraction !== null) {\r\n            console.log('line ' + JSON.stringify(line) + ' intersecting at ' + fraction);\r\n            ret.push(fraction);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nconst createRectangle = (from: Point, to: Point, width: number, texture: SceneTexture): SceneArea => {\r\n    const widthAdjustment = stretch(lineNormal(from, to), width / 2);\r\n    const centerline: Array<Point> = [from, to];\r\n    const topLine: Array<Point> = centerline.map(vertex => add(vertex, invert(widthAdjustment)));\r\n    const bottomLine: Array<Point> = centerline.reverse().map(vertex => add(vertex, widthAdjustment));\r\n    return {\r\n        vertices: [...topLine, ...bottomLine],\r\n        texture,\r\n        stretch: true\r\n    };\r\n}\r\n\r\nconst generateRoad = (from: Point, to: Point, width: number, texture: SceneTexture, river?: SceneArea): Array<SceneArea> => {\r\n    const widthAdjustment = stretch(lineNormal(from, to), width / 2);\r\n\r\n    const centerline: Array<Point> = [from, to];\r\n\r\n    if (river) {\r\n        const intersectionPoints = intersect(centerline as [Point, Point], river);\r\n        intersectionPoints.sort((a, b) => a - b);\r\n        if (intersectionPoints.length === 2) {\r\n            const bridge1 = add(from, stretch(subtract(to, from), intersectionPoints[0]));\r\n            const bridge2 = add(from, stretch(subtract(to, from), intersectionPoints[1]));\r\n            return [\r\n                ...generateRoad(from, bridge1, width, texture),\r\n                ...generateRoad(bridge2, to, width, texture),\r\n                createRectangle(bridge1, bridge2, width, {\r\n                    name: 'bridge'\r\n                })\r\n            ];\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < SPLITS; i++) {\r\n        const idx = randomInt(centerline.length - 1) + 1;\r\n        const split = splitLine(centerline[idx - 1], centerline[idx]);\r\n        if (split) {\r\n            centerline.splice(idx, 0, split);\r\n        }\r\n    }\r\n\r\n    const topLine: Array<Point> = centerline.map(vertex => add(vertex, invert(widthAdjustment)));\r\n    const bottomLine: Array<Point> = centerline.reverse().map(vertex => add(vertex, widthAdjustment));\r\n    return [{\r\n        vertices: [...topLine, ...bottomLine],\r\n        texture\r\n    }];\r\n}\r\n\r\nconst generateRoads = (endpoints: Array<{ from: Point, width: number }>, texture: SceneTexture, river?: SceneArea): Array<SceneArea> => {\r\n    if (endpoints.length > 2) {\r\n        const midpoint = endpoints.reduce((acc, curr) => [acc[0] + curr.from[0] / endpoints.length, acc[1] + curr.from[1] / endpoints.length] as Point, [0, 0] as Point);\r\n        return endpoints.flatMap(ep => generateRoad(ep.from, midpoint, ep.width, texture, river));\r\n    } else {\r\n        console.log('clean cut');\r\n        return generateRoad(endpoints[0].from, endpoints[1].from, endpoints[0].width, texture, river);\r\n    }\r\n\r\n}\r\n\r\n\r\nexport const Road = {\r\n    generate: generateRoads,\r\n}\r\n\r\n\r\n","import { randomBetween } from \"../Random\";\r\nimport { SceneArea, SceneObject, SceneTexture } from \"../Scene\";\r\nimport { Point, lineLength } from \"../Vector\";\r\n\r\ndeclare const OffscreenCanvas: any;\r\n\r\nconst MAX_TRIES = 1000;\r\n\r\nconst placeObject = (dim: Point, avoid: Array<SceneObject>, radius: number, tries: number): Point | null => {\r\n    let tried = 0;\r\n    while (tried++ < tries) {\r\n        const candidate: Point = [randomBetween(0, dim[0]), randomBetween(0, dim[1])];\r\n        const farEnough = avoid.every(ob => lineLength(ob.origin, candidate) > radius + ob.radius);\r\n        if (farEnough) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nconst spreadObjects = (dim: Point, avoid: Array<SceneObject>, count: number, height: number, radius: number, texture: SceneTexture): Array<SceneObject> => {\r\n\r\n    let ret: Array<SceneObject> = [];\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const newPoint = placeObject(dim, ret.concat(avoid), radius, MAX_TRIES);\r\n        if (newPoint === null) {\r\n            console.warn(`stopped object generation at ${i}, too many tries`);\r\n            break;\r\n        }\r\n        ret.push({\r\n            origin: newPoint,\r\n            orientation: randomBetween(0, 2 * Math.PI),\r\n            height,\r\n            radius,\r\n            texture\r\n        });\r\n    }\r\n    return ret;\r\n}\r\n\r\nconst inShapeFactory = (shape: SceneArea): ((point: Point) => boolean) => {\r\n\r\n    const canvas = new OffscreenCanvas(1, 1);\r\n    const context = canvas.getContext('2d') as unknown as CanvasRenderingContext2D;\r\n\r\n    const path: Path2D = new Path2D();\r\n    path.moveTo(...shape.vertices[0]);\r\n    shape.vertices.slice(1).forEach(vertex => {\r\n        path.lineTo(...vertex);\r\n    });\r\n    path.closePath();\r\n    return point => context.isPointInPath(path, ...point);\r\n}\r\n\r\nexport const SceneObjects = {\r\n    generate: (dim: Point, avoid: Array<SceneObject>, count: number, height: number, radius: number, texture: SceneTexture, exclude: Array<SceneArea> = []): Array<SceneObject> => {\r\n        const shapeChecker = exclude.map(inShapeFactory);\r\n\r\n        return spreadObjects(dim, avoid, count, height, radius, texture).filter(ob => shapeChecker.every(sc => !sc(ob.origin)));\r\n    }\r\n\r\n}","import { randomBetween, randomInt } from \"./Random\";\r\nimport { Scene, SceneArea, SceneObject } from \"./Scene\";\r\nimport { Point } from \"./Vector\";\r\nimport { Road } from \"./generators/Road\";\r\nimport { SceneObjects } from \"./generators/SceneObjects\";\r\nimport { Texture } from \"./Textures\";\r\n\r\n\r\nconst ROAD_EDGE_OVERHANG = 2;\r\n\r\nconst randomEdgePoint = (dim: Point): Point => {\r\n    const side = randomInt(4);\r\n    const chosenDim = dim[side % 2]; // width if side is even, height if side is odd;\r\n    const pos = randomBetween(chosenDim * 0.1, chosenDim * 0.9);\r\n\r\n    switch (side) {\r\n        case 0: return [pos, -ROAD_EDGE_OVERHANG];\r\n        case 1: return [dim[0] + ROAD_EDGE_OVERHANG, pos];\r\n        case 2: return [pos, dim[1] + ROAD_EDGE_OVERHANG];\r\n        case 3: return [-ROAD_EDGE_OVERHANG, pos];\r\n        default: throw new Error('randomInt(4) returned a weird value');\r\n    }\r\n}\r\n\r\n\r\n\r\nexport const SceneGenerator = {\r\n    create: (dim: Point, baseTexture: string): Scene => ({\r\n        layers: {\r\n            base: {\r\n                areas: [{\r\n                    vertices: [[0, 0], [dim[0], 0], dim, [0, dim[1]]],\r\n                    texture: {\r\n                        name: baseTexture,\r\n                    },\r\n                }],\r\n                type: 'base'\r\n            }\r\n        },\r\n        shadowVector: [0, 0],\r\n        size: dim\r\n    }),\r\n    river: (scene: Scene, layer: string, mainWidth: number, texture: Texture): Scene => {\r\n        const dim = scene.size;\r\n\r\n        const mainEndpoints: Array<{ from: Point, width: number }> = [\r\n            { from: [randomBetween(0.1 * dim[0], 0.9 * dim[0]), -ROAD_EDGE_OVERHANG], width: mainWidth },\r\n            { from: [randomBetween(0.1 * dim[0], 0.9 * dim[0]), dim[1] + ROAD_EDGE_OVERHANG], width: mainWidth }\r\n        ];\r\n\r\n        scene.layers[layer] = {\r\n            areas: Road.generate(mainEndpoints, {\r\n                name: texture.name\r\n            }),\r\n            type: 'river'\r\n        };\r\n\r\n        return scene;\r\n    },\r\n    roads: (scene: Scene, layer: string, mainWidth: number, sideRoads: Array<number>, texture: Texture, river?: SceneArea): Scene => {\r\n        const dim = scene.size;\r\n\r\n        let mainEndpoints: Array<{ from: Point, width: number }> = [\r\n            { from: [-ROAD_EDGE_OVERHANG, randomBetween(0.1 * dim[1], 0.9 * dim[1])], width: mainWidth },\r\n            { from: [dim[0] + ROAD_EDGE_OVERHANG, randomBetween(0.1 * dim[1], 0.9 * dim[1])], width: mainWidth }\r\n        ];\r\n\r\n        const extraEndpoints = sideRoads.map(width => ({\r\n            from: randomEdgePoint(dim),\r\n            width: width\r\n        }));\r\n\r\n        scene.layers[layer] = {\r\n            areas: Road.generate([...mainEndpoints, ...extraEndpoints], {\r\n                name: texture.name\r\n            }, river),\r\n            type: 'road'\r\n        };\r\n\r\n        return scene;\r\n    },\r\n    objects: (scene: Scene, layer: string, count: number, texture: Texture): Scene => {\r\n        const currentObjects: Array<SceneObject> = scene.layers[layer]?.objects ?? [];\r\n        const roadAreas: Array<SceneArea> = [...scene.layers.road.areas ?? [], ...scene.layers.river.areas ?? []];\r\n        const newObjects = SceneObjects.generate(scene.size, currentObjects, count, texture.height, texture.radius, {\r\n            name: texture.name,\r\n        }, roadAreas);\r\n        scene.layers[layer] = {\r\n            objects: currentObjects.concat(newObjects),\r\n            type: 'object'\r\n        }\r\n        return scene;\r\n    }\r\n}\r\n","export default __webpack_public_path__ + \"static/media/gravel.fadd9e77.jpg\";","export default __webpack_public_path__ + \"static/media/grass.1bdb8368.jpg\";","export default __webpack_public_path__ + \"static/media/tree.251e1382.png\";","export default __webpack_public_path__ + \"static/media/tree2.b70d7e22.png\";","export default __webpack_public_path__ + \"static/media/rock.f8863753.png\";","export default __webpack_public_path__ + \"static/media/dirtroad.3f84b32a.jpg\";","export default __webpack_public_path__ + \"static/media/lightergrass.775fd4e3.jpg\";","export default __webpack_public_path__ + \"static/media/water.5bcc6117.jpg\";","export default __webpack_public_path__ + \"static/media/bridge.01e94610.png\";","import React, { useEffect, useReducer } from 'react';\r\n\r\nimport gravel from './textures/gravel.jpg';\r\nimport grass from './textures/grass.jpg';\r\nimport tree from './textures/tree.png';\r\nimport tree2 from './textures/tree2.png';\r\nimport rock from './textures/rock.png';\r\nimport dirt from './textures/dirtroad.jpg';\r\nimport lighterGrass from './textures/lightergrass.jpg';\r\nimport water from './textures/water.jpg';\r\nimport bridge from './textures/bridge.png';\r\n\r\nexport interface Texture {\r\n    name: string;\r\n    category: string;\r\n    url: string;\r\n    type: 'single' | 'pattern';\r\n    scale: number;\r\n    height: number;\r\n    radius: number;\r\n    loadedImage: HTMLImageElement;\r\n}\r\n\r\nexport const TINTS: Record<string, string> = {\r\n    sunset: 'rgba(230,120,0,0.15)',\r\n    evening: 'rgba(0,0,250,0.2)',\r\n    night: 'rgba(0,0,250,0.3)',\r\n}\r\n\r\nexport const TEXTURES: Array<Omit<Texture, 'loadedImage'>> = [\r\n    {\r\n        name: 'water',\r\n        url: water,\r\n        type: 'pattern',\r\n        scale: 1,\r\n        category: 'river',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'bridge',\r\n        url: bridge,\r\n        type: 'pattern',\r\n        scale: 1,\r\n        category: 'bridge',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'gravel',\r\n        url: gravel,\r\n        type: 'pattern',\r\n        scale: 1,\r\n        category: 'road',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'dirt',\r\n        url: dirt,\r\n        type: 'pattern',\r\n        scale: 1,\r\n        category: 'road',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'grass',\r\n        url: grass,\r\n        type: 'pattern',\r\n        scale: 3,\r\n        category: 'ground',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'lighter grass',\r\n        url: lighterGrass,\r\n        type: 'pattern',\r\n        scale: 1,\r\n        category: 'ground',\r\n        height: 0,\r\n        radius: 0,\r\n    },\r\n    {\r\n        name: 'tree',\r\n        url: tree,\r\n        type: 'single',\r\n        scale: 2,\r\n        category: 'tree',\r\n        height: 8,\r\n        radius: 2,\r\n    },\r\n    {\r\n        name: 'bigtree',\r\n        url: tree,\r\n        type: 'single',\r\n        scale: 4,\r\n        category: 'tree',\r\n        height: 16,\r\n        radius: 4,\r\n    },\r\n    {\r\n        name: 'other tree',\r\n        url: tree2,\r\n        type: 'single',\r\n        scale: 3,\r\n        category: 'tree',\r\n        height: 12,\r\n        radius: 3,\r\n    },\r\n    {\r\n        name: 'rock',\r\n        url: rock,\r\n        type: 'single',\r\n        scale: 0.3,\r\n        category: 'rock',\r\n        height: 2,\r\n        radius: 0.5,\r\n    },\r\n]\r\n\r\nexport const Textures: React.FC<{ onLoaded: (textures: Array<Texture>) => unknown }> = ({ onLoaded }) => {\r\n\r\n    const [imagesLoaded, imageLoaded] = useReducer((prevstate: number, action: {}) => {\r\n        return prevstate + 1;\r\n    }, 0);\r\n\r\n    useEffect(() => {\r\n        if (imagesLoaded === TEXTURES.length) {\r\n            onLoaded(TEXTURES.map(t => ({ ...t, loadedImage: document.getElementById(t.name) as HTMLImageElement })));\r\n        }\r\n    }, [imagesLoaded, onLoaded]);\r\n\r\n    return <>\r\n        {TEXTURES.map(t => <img key={t.name} src={t.url} id={t.name} style={{ display: 'none' }} alt='' onLoad={imageLoaded} />)}\r\n    </>;\r\n}","import React from 'react';\r\nimport { Select } from 'semantic-ui-react';\r\nimport { Texture } from './Textures';\r\n\r\nexport const TextureSelector: React.FC<{ textures: Record<string, Texture>, type: 'single' | 'pattern', value: string, onChange: (name: string) => unknown }> = ({ textures, type, value, onChange }) => {\r\n    return <Select\r\n        value={value}\r\n        onChange={(_, { value }) => onChange(value as string)}\r\n        placeholder='Select texture'\r\n        options={\r\n            Object.keys(textures).filter(t => textures[t].type === type).map(t => ({ key: t, text: t, value: t, image: textures[t].url }))\r\n        }\r\n    />\r\n}","import React, { useState } from 'react';\r\nimport { Button, ButtonGroup, Card, Header, Input } from 'semantic-ui-react';\r\nimport { Texture } from './Textures';\r\nimport { TextureSelector } from './TextureSelector';\r\n\r\nexport interface ObjectLayerCardProps {\r\n    name: string;\r\n    textures: Record<string, Texture>;\r\n    generateObjects: (count: number, texture: string) => unknown;\r\n    clearLayer: () => unknown;\r\n    deleteLayer: () => unknown;\r\n}\r\n\r\n\r\nexport const ObjectLayerCard: React.FC<ObjectLayerCardProps> = ({ name, textures, generateObjects, clearLayer, deleteLayer }) => {\r\n    const [count, setCount] = useState<number>(0);\r\n    const [texture, setTexture] = useState<string>('');\r\n\r\n    return <Card>\r\n        <Card.Header><Header textAlign='center'>Object layer: {name}</Header></Card.Header>\r\n        <Card.Content>\r\n            <Input type='number' label='No. of objects:' value={count} step={1} onChange={e => setCount(Number(e.target.value))} />\r\n            <TextureSelector value={texture} textures={textures ?? {}} type='single' onChange={setTexture} />\r\n            <ButtonGroup>\r\n                <Button content='Add' icon='plus' disabled={count === 0 || texture === ''} onClick={() => generateObjects(count, texture)} />\r\n                <Button content='Clear' icon='eraser' onClick={clearLayer} />\r\n                <Button content='Remove' icon='remove' onClick={deleteLayer} />\r\n            </ButtonGroup>\r\n        </Card.Content>\r\n    </Card>\r\n}","import React, { useState } from 'react';\r\nimport { Button, Card, Header, Input } from 'semantic-ui-react';\r\n\r\nexport interface CreateLayerCardProps {\r\n    layers: Array<string>;\r\n    onCreate: (name: string) => unknown;\r\n}\r\n\r\n\r\nexport const CreateLayerCard: React.FC<CreateLayerCardProps> = ({ layers, onCreate }) => {\r\n    const [name, setName] = useState<string>('');\r\n\r\n    return <Card>\r\n        <Card.Header><Header textAlign='center'>Add new layer</Header></Card.Header>\r\n        <Card.Content>\r\n            <Input label='Layer name' value={name} onChange={e => setName(e.target.value)} />\r\n            <Button\r\n                icon='clone outline'\r\n                content='Create'\r\n                disabled={name === '' || layers.includes(name)}\r\n                onClick={() => {\r\n                    onCreate(name);\r\n                    setName('');\r\n                }} />\r\n        </Card.Content>\r\n    </Card>\r\n}","import { range } from 'lodash';\r\nimport React from 'react';\r\nimport { Button, List, SemanticICONS } from 'semantic-ui-react';\r\n\r\nexport interface ListComponentProps {\r\n    items: number;\r\n    itemFactory: (index: number) => JSX.Element;\r\n    addItem: () => unknown;\r\n    removeItem: (index: number) => unknown;\r\n    itemIcon?: SemanticICONS;\r\n    name: string;\r\n}\r\n\r\nexport const ListComponent: React.FC<ListComponentProps> = ({ items, itemFactory, addItem, removeItem, itemIcon, name }) => {\r\n    return <List divided relaxed>\r\n        {range(0, items).map(index => <List.Item>\r\n            {itemIcon && <List.Icon name={itemIcon} />}\r\n            <List.Content>\r\n                {itemFactory(index)} <Button floated='right' icon='remove' onClick={() => removeItem(index)} />\r\n            </List.Content>\r\n        </List.Item>)}\r\n        <List.Item>\r\n            <List.Content>\r\n                <Button icon='plus' content={`Add ${name}`} onClick={addItem} />\r\n            </List.Content>\r\n        </List.Item>\r\n    </List>;\r\n}","import React, { useState } from 'react';\r\nimport { Button, Card, Header, Input } from 'semantic-ui-react';\r\nimport { ListComponent } from './ListComponent';\r\nimport { Texture } from './Textures';\r\nimport { TextureSelector } from './TextureSelector';\r\n\r\nexport interface RoadLayerCardProps {\r\n    name: string;\r\n    textures: Record<string, Texture>;\r\n    generateRoads: (mainWidth: number, sideRoads: Array<number>, texture: string) => unknown;\r\n}\r\n\r\n\r\nexport const RoadLayerCard: React.FC<RoadLayerCardProps> = ({ name, textures, generateRoads }) => {\r\n    const [mainWidth, setMainWidth] = useState<number>(0);\r\n    const [texture, setTexture] = useState<string>('');\r\n    const [sideRoads, setSideRoads] = useState<Array<number>>([]);\r\n\r\n    return <Card>\r\n        <Card.Header><Header textAlign='center'>Road Layer</Header></Card.Header>\r\n        <Card.Content>\r\n            <Input label='Main road width:' type='number' value={mainWidth} onChange={e => setMainWidth(Number(e.target.value))} />\r\n            <TextureSelector value={texture} textures={textures ?? {}} type='pattern' onChange={setTexture} />\r\n            <ListComponent\r\n                items={sideRoads.length}\r\n                name='side road'\r\n                itemIcon='road'\r\n                addItem={() => {\r\n                    setSideRoads([...sideRoads, 0]);\r\n                }}\r\n                removeItem={index => {\r\n                    sideRoads.splice(index, 1);\r\n                    setSideRoads([...sideRoads]);\r\n                }}\r\n                itemFactory={index => <Input label='Side road width:' type='number' value={sideRoads[index]} onChange={e => { sideRoads[index] = Number(e.target.value); setSideRoads([...sideRoads]); }} />} />\r\n            <Button icon='redo' content='Generate' disabled={texture === ''} onClick={() => generateRoads(mainWidth, sideRoads, texture)} />\r\n        </Card.Content>\r\n    </Card>\r\n}","import React from 'react';\r\nimport { Card, Header, Input, Select } from 'semantic-ui-react';\r\nimport { TINTS } from './Textures';\r\nimport { fromPolar, lineLength, Point } from './Vector';\r\n\r\nexport interface VisualsCardProps {\r\n    shadowVector: Point;\r\n    onShadowChange: (shadowVector: Point) => unknown;\r\n    tint: string;\r\n    onTintChange: (tint: string) => unknown;\r\n    resolution: number;\r\n    onResolutionChange: (resolution: number) => unknown;\r\n}\r\n\r\n\r\nexport const VisualsCard: React.FC<VisualsCardProps> = ({ tint, shadowVector, onShadowChange, onTintChange, resolution, onResolutionChange }) => {\r\n    const shadowLength = Math.round(lineLength(shadowVector) * 10);\r\n    const shadowAngle = Math.round(Math.atan2(shadowVector[1], shadowVector[0]) * 180 / Math.PI);\r\n    return <Card>\r\n        <Card.Header><Header textAlign='center'>Visual tweaks</Header></Card.Header>\r\n        <Card.Content>\r\n            <Select value={tint || 'none'} onChange={(_, { value }) => onTintChange(value as string)} options={\r\n                [{ key: '', value: 'none', text: 'no tint' }, ...Object.keys(TINTS).map(t => ({ key: t, value: TINTS[t], text: t }))]\r\n            } />\r\n            <br />\r\n            <Input label='Shadow length' type='number' value={shadowLength} onChange={e => onShadowChange(fromPolar(Number(e.target.value) / 10, Number(shadowAngle) * Math.PI / 180))} />\r\n            <Input label='Shadow direction' type='number' step={5} value={shadowAngle} onChange={e => onShadowChange(fromPolar(shadowLength / 10, Number(e.target.value) * Math.PI / 180))} />\r\n            <Input label='Pixels per grid' type='number' step={5} value={resolution} onChange={e => onResolutionChange(Number(e.target.value))} />\r\n        </Card.Content>\r\n    </Card>\r\n}","import React, { useState } from 'react';\r\nimport { Button, Card, Header, Input } from 'semantic-ui-react';\r\nimport { Texture } from './Textures';\r\nimport { TextureSelector } from './TextureSelector';\r\nimport { Point } from './Vector';\r\n\r\ninterface BaseLayerCardProps {\r\n    textures: Record<string, Texture>;\r\n    createScene: (dimensions: Point, baseTexture: string) => unknown;\r\n}\r\n\r\nexport const BaseLayerCard: React.FC<BaseLayerCardProps> = ({ textures, createScene }) => {\r\n\r\n    const [texture, setTexture] = useState<string>('');\r\n    const [width, setWidth] = useState<number>(10);\r\n    const [height, setHeight] = useState<number>(10);\r\n\r\n    return <Card>\r\n        <Card.Header><Header textAlign='center'>Scene</Header></Card.Header>\r\n        <Card.Content>\r\n            <Input type='number' label='Width' value={width} step={20} onChange={e => setWidth(Number(e.target.value))} />\r\n            <Input type='number' label='Height' value={height} step={20} onChange={e => setHeight(Number(e.target.value))} />\r\n            <TextureSelector value={texture} textures={textures ?? {}} type='pattern' onChange={setTexture} />\r\n\r\n            <Button\r\n                icon='clone outline'\r\n                content='Create'\r\n                disabled={texture === ''}\r\n                onClick={() => createScene([width, height], texture)} />\r\n        </Card.Content>\r\n    </Card>\r\n}","import React, { useState } from 'react';\r\nimport { Button, Card, Header, Input } from 'semantic-ui-react';\r\nimport { Texture } from './Textures';\r\nimport { TextureSelector } from './TextureSelector';\r\n\r\nexport interface RiverLayerCardProps {\r\n    name: string;\r\n    textures: Record<string, Texture>;\r\n    generateRiver: (mainWidth: number, texture: string) => unknown;\r\n}\r\n\r\n\r\nexport const RiverLayerCard: React.FC<RiverLayerCardProps> = ({ name, textures, generateRiver }) => {\r\n    const [mainWidth, setMainWidth] = useState<number>(0);\r\n    const [texture, setTexture] = useState<string>('');\r\n\r\n    return <Card>\r\n        <Card.Header><Header textAlign='center'>River Layer</Header></Card.Header>\r\n        <Card.Content>\r\n            <Input label='River width:' type='number' value={mainWidth} onChange={e => setMainWidth(Number(e.target.value))} />\r\n            <TextureSelector value={texture} textures={textures ?? {}} type='pattern' onChange={setTexture} />\r\n            <Button icon='redo' content='Generate' disabled={texture === ''} onClick={() => generateRiver(mainWidth, texture)} />\r\n        </Card.Content>\r\n    </Card>\r\n}","import React, { useCallback, useEffect, useRef, useState } from 'react';\r\nimport { drawScene } from './ShapeDrawer';\r\nimport { SceneGenerator } from './SceneGenerator';\r\nimport { Point } from './Vector';\r\nimport { Texture, Textures } from './Textures';\r\nimport { Scene } from './Scene';\r\nimport { ObjectLayerCard } from './ObjectLayerCard';\r\nimport { CreateLayerCard } from './CreateLayerCard';\r\nimport { RoadLayerCard } from './RoadLayerCard';\r\nimport { Card, Checkbox } from 'semantic-ui-react';\r\nimport { VisualsCard } from './VisualsCard';\r\nimport { BaseLayerCard } from './BaseLayerCard';\r\nimport { RiverLayerCard } from './RiverLayerCard';\r\n\r\nconst SCALE = 70;\r\n\r\nexport const Canvas: React.FC<{}> = () => {\r\n\r\n    const canvasRef = useRef<HTMLCanvasElement>(null);\r\n    const [textures, setTeztures] = useState<Record<string, Texture>>();\r\n    const [scene, setScene] = useState<Scene>(SceneGenerator.create([10, 10], 'grass'));\r\n    const [resolution, setResolution] = useState<number>(SCALE);\r\n    const [debug, setDebug] = useState<boolean>(false);\r\n\r\n    const regenerateRoads = useCallback((layer: string, mainWidth: number, sideRoads: Array<number>, texture: string) => {\r\n        if (textures) {\r\n            setScene({ ...SceneGenerator.roads(scene, layer, mainWidth, sideRoads, textures[texture], scene.layers.river.areas?.[0]) });\r\n        }\r\n    }, [scene, textures]);\r\n\r\n    const regenerateRiver = useCallback((layer: string, mainWidth: number, texture: string) => {\r\n        if (textures) {\r\n            setScene({ ...SceneGenerator.river(scene, layer, mainWidth, textures[texture]) });\r\n        }\r\n    }, [scene, textures]);\r\n\r\n\r\n    const clearLayer = useCallback((layer: string) => {\r\n        delete scene.layers?.[layer]?.areas;\r\n        delete scene.layers?.[layer]?.objects;\r\n        setScene({ ...scene });\r\n    }, [scene]);\r\n\r\n    const removeLayer = useCallback((layer: string) => {\r\n        delete scene.layers?.[layer];\r\n        setScene({ ...scene });\r\n    }, [scene]);\r\n\r\n    const createLayer = useCallback((layer: string) => {\r\n        scene.layers[layer] = { type: 'object' };\r\n        setScene({ ...scene });\r\n    }, [scene]);\r\n\r\n    const generateObjects = useCallback((layer: string, count: number, texture: string) => {\r\n        if (textures) {\r\n            SceneGenerator.objects(scene, layer, count, textures[texture]);\r\n        }\r\n        setScene({ ...scene });\r\n    }, [scene, textures]);\r\n\r\n    const createScene = useCallback((dimension: Point, texture: string) => {\r\n        setScene(SceneGenerator.create(dimension, texture));\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        if (textures) {\r\n            const canvas = canvasRef.current;\r\n            if (canvas) {\r\n                const context = canvas.getContext('2d');\r\n                if (context) {\r\n                    drawScene(context, textures, scene, debug);\r\n                }\r\n            }\r\n        }\r\n    }, [textures, scene, resolution, debug]);\r\n\r\n    const onTexturesLoaded = useCallback((textures: Array<Texture>) => {\r\n        const textureMap: Record<string, Texture> = textures.reduce((acc, curr) => { acc[curr.name] = curr; return acc; }, {} as Record<string, Texture>);\r\n        setTeztures(textureMap);\r\n    }, []);\r\n\r\n    return <>\r\n        <Textures onLoaded={onTexturesLoaded} />\r\n        <div style={{ display: 'flex' }}>\r\n            <div>\r\n                <Card.Group itemsPerRow={1}>\r\n                    <BaseLayerCard textures={textures ?? {}} createScene={createScene} />\r\n                    <RiverLayerCard name='river' textures={textures ?? {}} generateRiver={regenerateRiver.bind(null, 'river')} />\r\n                    <RoadLayerCard name='road' textures={textures ?? {}} generateRoads={regenerateRoads.bind(null, 'road')} />\r\n                    {Object.keys(scene.layers).filter(layer => scene.layers[layer].type === 'object').map(layer => {\r\n                        return <ObjectLayerCard\r\n                            name={layer}\r\n                            textures={textures ?? {}}\r\n                            generateObjects={(count, texture) => generateObjects(layer, count, texture)}\r\n                            clearLayer={() => clearLayer(layer)}\r\n                            deleteLayer={() => removeLayer(layer)}\r\n                        />\r\n                    })}\r\n                    {scene.layers.road && <CreateLayerCard layers={Object.keys(scene.layers)} onCreate={createLayer} />}\r\n\r\n                    <VisualsCard tint={scene.tint ?? ''} shadowVector={scene.shadowVector} onShadowChange={shadow => {\r\n                        scene.shadowVector = shadow;\r\n                        setScene({ ...scene });\r\n                    }}\r\n                        onTintChange={tint => {\r\n                            scene.tint = tint;\r\n                            setScene({ ...scene });\r\n                        }}\r\n                        resolution={resolution}\r\n                        onResolutionChange={setResolution}\r\n                    />\r\n                </Card.Group>\r\n\r\n                <Checkbox label='Debug mode' checked={debug} onChange={(_, data) => setDebug(!debug)} toggle />\r\n            </div>\r\n            <canvas style={{ width: `${scene.size[0] * resolution}px`, height: `${scene.size[1] * resolution}px` }} ref={canvasRef} width={`${scene.size[0] * resolution}px`} height={`${scene.size[1] * resolution}px`} />\r\n        </div>\r\n    </>;\r\n}","import React from 'react';\nimport { Canvas } from './Canvas';\n\nimport 'semantic-ui-css/semantic.min.css'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Canvas />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}